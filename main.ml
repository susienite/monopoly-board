open Monopoly
open Command
open State

(**[curr_tile st] is the current tile the state [st] is on. *)
let curr_tile st = List.assoc (curr_player st) (player_pos st) 

(**[pp_color s] is the prettified string for the property color [s]. *)
let pp_color (s : ANSITerminal.color) =
  match s with
  | Black ->  "Black Property"
  | Red -> "Red Property"
  | Green -> "Green Property"
  | Yellow -> "Yellow Property"
  | Blue -> "Blue Property"
  | Magenta -> "Magenta Property"
  | Cyan -> "Cyan Property"
  | White -> "White Property"
  | _ -> raise (Failure "Invalid style in tile set")

(** [print_properties game st] prints the properties owned by player 
    in state [st] in game [game] *)
let print_properties game st = 
  let rec print_lst lst = 
    match lst with 
    |[] -> "no property"
    |h::[] -> (if (get_mortgaged_bool h st) then "*" else "") ^(tile_name game h)
    |h::t -> (if (get_mortgaged_bool h st) then "*" else "") ^ (tile_name game h) ^ ", " ^ (print_lst t) in
  print_lst (get_properties (curr_player st) st) 

(** [print_players st] prints the players currently in the state [st] *)
let print_players st = 
  let rec print_lst lst = 
    match lst with 
    | [] -> "none"
    | h::[] -> "Player " ^ string_of_int h
    | h::t -> "Player " ^ string_of_int h ^ ", " ^ print_lst t in
  print_lst (elim_player_lst st)

(**[print_tile_func game st] prints the tile function of the current tile in
   	   the state [st] in the game [game]. *)
let print_tile_func game st = 
  match (tile_func game (curr_tile st)) with 
  | Property s -> pp_color s
  | Chest -> "Chest. You got a card!"
  | Chance -> "Chance. You got a card!"
  | Income -> "Income Tax. Lose $200."
  | Luxury -> "Luxury Tax. Lose $100. "
  | Go -> "Go. Gain $200 when pass Go."
  | Railroad -> "Railroad"
  | Utilities -> "Utilities"
  | GoToJail -> "Go To Jail. To get out of jail, roll two 6s, wait 2 turns, or apply 'Get Out of Jail' card."
  | Jail -> "Jail"
  | FreeParking -> "Free Parking"

(**[print_owner game st] prints the owner of the current tile in
   	   the state [st] in the game [game]. *)
let print_owner game st = 
  match (get_tile_owner (curr_tile st) st) with
  | (-1) -> "cannot be owned" 
  | 0 -> "not owned"
  | 1 -> "player 1"
  | 2 -> "player 2"
  | 3 -> "player 3"
  | 4 -> "player 4"
  | _  -> "failure to find owner" 

let print_mon int =
  match int with 
  | (-1) -> "none"
  | _ -> "$" ^ string_of_int int  

let print_hh int =
  match int with 
  | (-1) -> "none"
  | _ -> string_of_int int  

let print_bool bool = 
  match bool with 
  | true -> "yes"
  | false -> "no"

(** [playing_game game st] is the helper function for play_game. It keeps the 
    game going by comprehending was the user says and moving to the next state if 
    needed or alerts the user their command was invalid 
    Example: the player can type "roll" and the player will move the 
    amount of spaces generated by the command "roll". 
    Raises: Malformed when the command is typed incorrectly
            Empty when there is no command*)
let rec playing_game game st = 
  match (parse (read_line ())) with
  | exception (Command.Malformed) -> 
    print_endline "> Are you sure that is a command? Try \"help\'."; 
    print_string "> "; playing_game game st
  | exception (Command.Empty) -> print_endline "> Are you sure you typed 
    something?"; 
    print_string "> "; playing_game game st
  | Quit -> ANSITerminal.(print_string [red] "\n GAME OVER \n\n"); exit 0 
  | Roll -> let next_state = (roll st game)  in playing_game game next_state
  | Rolln x -> let next_state = pay_rent(rolln st game x) game x in playing_game game next_state
  | Buy -> playing_game game (buy st game)
  | BuyHouse x -> begin
      match tile_short_to_id game x with 
      | None -> begin print_endline("That is not a valid property shortcode.");
          print_endline("To buy a house, type \"buy house\" followed by a tile shortcode shown on the board, in all caps.\n");
          print_string ("> "); playing_game game st end
      | Some i -> let next_state = buy_house st game i in playing_game game next_state end 
  | BuyHotel x -> begin 
      match tile_short_to_id game x with 
      | None -> begin print_endline("That is not a valid property shortcode."); 
          print_endline("To buy a hotel, type \"buy hotel\" followed by a tile shortcode shown on the board, in all caps.\n"); 
          print_string("> "); playing_game game st end
      | Some i -> let next_state = buy_hotel st game i in playing_game game next_state end
  | SellHouse x -> begin 
      match tile_short_to_id game x with 
      | None -> begin print_endline("That is not a valid property shortcode.");
          print_endline("To sell a house, type \"sell house\" followed by a tile shortcode shown on the board, in all caps.\n");
          print_string ("> "); playing_game game st end
      | Some i -> let next_state = sell_house st game i in playing_game game next_state end
  | SellHotel x -> begin 
      match tile_short_to_id game x with 
      | None -> begin print_endline("That is not a valid property shortcode.");
          print_endline("To sell a hotel, type \"sell hotel\" followed by a tile shortcode shown on the board, in all caps.\n");
          print_string ("> "); playing_game game st end
      | Some i -> let next_state = sell_hotel st game i in playing_game game next_state end
  | Mortgage x -> begin 
      match tile_short_to_id game x with 
      | None -> begin print_endline("That is not a valid property shortcode.");
          print_endline("To mortgage a property, type \"mortgage\" followed by a tile shortcode shown on the board, in all caps.\n");
          print_string ("> "); playing_game game st end
      | Some i -> let next_state = mortgage st game i in playing_game game next_state end
  | UnMortgage x -> begin 
      match tile_short_to_id game x with 
      | None -> begin print_endline("That is not a valid property shortcode.");
          print_endline("To unmortgage a property, type \"unmortgage\" followed by a tile shortcode shown on the board, in all caps.\n");
          print_string ("> "); playing_game game st end
      | Some i -> let next_state = unmortgage st game i in playing_game game next_state end
  | End -> if get_rolled st then playing_game game (next_turn st game)
    else begin print_endline("You must roll before ending your turn.\n");
      print_string("> "); playing_game game st end
  | Tile ->
    print_endline ("About this tile" );
    print_endline (">> " ^ "Name: " ^ tile_name game (curr_tile st)); 
    print_endline(">> " ^ "Description: " ^ print_tile_func game st); 
    print_endline (">> " ^ "Price: " ^ print_mon (tile_price game (curr_tile st))); 
    print_endline (">> " ^ "Rent: " ^ print_mon (tile_rent game (curr_tile st)));
    print_endline (">> " ^ "House Price: " ^ print_mon (tile_house_cost game (curr_tile st)));
    print_endline (">> " ^ "Hotel Price: " ^ print_mon (tile_hotel_cost game (curr_tile st)));
    print_endline (">> " ^ "# houses on this tile: " ^ print_hh (tile_houses game (curr_tile st)));
    print_endline (">> " ^ "# hotels on this tile: " ^ print_hh (tile_hotels game (curr_tile st)));
    print_endline (">> " ^ "Mortgaged: " ^ print_bool (get_mortgaged_bool (curr_tile st) st)); 
    print_endline (">> " ^ "Owner: " ^ print_owner game st); 
    print_endline ("Rent is the amount of money the owner receives when another player lands on this property.");
    print_endline ("You can only buy a house on color group if you own all the properties under that color.");
    print_endline ("You can only buy a hotel if you own 4 houses under the same property.");
    print_endline ("If the property is not owned, you may purchase this property by typing \"buy\".\n");
    print_string  "> "; playing_game game st
  | Status ->     
    print_endline("Player " ^ string_of_int (curr_player st) ^ ", " ^ 
                  "you are on " ^ tile_name game (curr_tile st));
    print_endline ("You have the following : "); 
    print_endline (">> Money: $" ^ string_of_int (get_pocket (curr_player st) st)); 
    print_endline (">> Properties (* if Mortgaged): " ^ (print_properties game st)); 
    print_endline (">> Own a \"Get Out of Jail Card\" ? " ^ (print_bool (get_outcard (curr_player st) st))) ; 
    print_endline ("Eliminated players: " ^ print_players st ^ "\n");  
    print_string  "> "; playing_game game st
  | Chance x -> let card_state = choose_chance st game x in playing_game game card_state;  
  | Chest x ->  let card_state = choose_comm st game x in playing_game game card_state; 
  | GetOutCard -> playing_game game (jail_card st game); 
  | JailFee ->  if (get_jail_bool (curr_player st) st = true )then 
      playing_game game (pay_jail st game) else 
      playing_game game st 
  | Help -> print_endline ("This is help."); 
    print_endline ("To begin, type \"roll\" to roll the dice."); 
    print_endline ("You may check your status by entering \"status\"."); 
    print_endline ("You may check the properties of your current tile by entering \"tile\"."); 
    print_endline ("If the tile does not have an owner, you can buy the property by entering \"buy\".");
    print_endline ("If you land on an owned property, you pay a rent fee. Money will automatically be deducted from your pocket.");
    print_endline ("If you own all properties in a set (denoted by color on the board), you can buy a house on one
of these properties by typing \"buy house\" followed by the shortcode of the property. When a property has four houses,
you can buy a hotel by typing \"buy hotel\" followed by the shortcode of the property.");
    print_endline ("Some properties are special and are not for sale.");  
    print_endline ("If you land in jail, you may pay the $50 fine by typing \"pay jail fee\".
    You may also use your Get Out of Jail card by typing \"get out\". If you choose not to get
    out of jail, you are eliminated from the game." );  
    print_endline("After rolling (possibly buying), type \"end\" to end your turn."); 
    print_endline("Type \"quit\" to quit the game. \n"); 
    print_string  "> "; playing_game game st

(** [play_game f] starts the game in file [f]. 
    Example: play_game monopoly.json starts the monopoly game. 
    Raises: exception when an invalid file name is given. *)
let rec play_game f num =
  let monopoly = from_json (Yojson.Basic.from_file f)in
  let start = init_state monopoly num in 
  print_board start (get_tile_info monopoly);
  ANSITerminal.(print_string [red] ">>>>>>>>>>>>>>>> \n"); 
  print_endline ("Instructions on Monopoly: ");
  print_endline ("All players begin in Go with $1500.");
  print_endline ("To start, Player 1 can roll 2 die by entering \"roll\".");
  print_endline ("The player moves the number of spaces given by \"roll\".");
  print_endline ("If the tile is not an owned property, the player can buy by entering \"buy\".");
  print_endline ("You can only buy a house if you own all properties under a color by entering \"buy house [NAME ON BOARD]\".");
  print_endline ("You can only buy a hotel if you own 4 houses on same property by entering \"buy hotel [NAME ON BOARD]\".");
  print_endline ("You may sell your houses and hotels and get the amount you paid for them."); 
  print_endline ("Money will be automatically deducted from the player's pocket.");
  print_endline ("If the player lands on another's owned property, the player has to pay a rent fee.");
  print_endline ("The rent fee is automatically deducted from the player's pocket.");
  print_endline ("Some properties are special and are not for sale.");  
  print_endline ("If you are in jail, you must either pay a fee of $50 or use a Get Out of Jail card within the next 3 turns."); 
  print_endline ("Mortgaged properties do not collect rent and you can't build on them.");  
  print_endline ("The player can check his/her properties and money by entering \"status\".");
  print_endline ("The player can also learn about the current tile by entering \"tile\".");
  print_endline ("If there is more than one player in the game, the player must end their turn by entering \"end\".");
  print_endline ("The player loses when the player does not have the money to pay the rent fee.");
  print_endline ("To quit the game, please enter \"quit\".");
  ANSITerminal.(print_string [red] ">>>>>>>>>>>>>>>> \n"); 
  print_endline ("Look at the board to view your position as you move along the game.");
  print_endline ("To start your turn, type \"roll\"! \n");
  print_string  "> ";
  playing_game monopoly start

(** [pick_file inte] tries to run play_game with the number of players, inte, and
    a correct input from the terminal, which is defined as a .json board file.*)
let rec pick_file inte =
  match read_line () with
  | exception End_of_file -> print_endline ("fail");
  | file_name ->
    try 
      play_game file_name inte
    with Sys_error file_name -> print_endline ("Incorrect file. Please try again!");
      print_endline ("Or quit the terminal if you don't want to play.");
      print_string("> "); pick_file inte

(** [get_num] checks for the correct number of players inputted in the terminal.
    If it is correct, it will let the player pick a file using [pick_file inte] *)
let rec get_num () =
  match read_line () with 
  | exception End_of_file -> failwith("End of File")
  | s -> 
    match (int_of_string_opt s) with 
    | None ->
      print_endline("That is not a valid number! Try again.\n"); 
      print_string("> "); get_num ()
    | Some i -> 
      if i < 2 then begin  print_endline("That is not a valid number! Try again.\n"); 
        print_string("> "); get_num () end
      else if i > 4 then begin print_endline("That is not a valid number! Try again.\n"); 
        print_string("> "); get_num () end
      else begin
        print_endline ("Great! The game will start with " ^ string_of_int i ^ " players.");
        print_endline ("To start, please specify the .json file.");
        print_string ("> ");
        pick_file i end

(** [main ()] prompts for the game to play, then starts it. 
    Example: Entering monopoly.json starts the monopoly game.*)
let main () =

  ANSITerminal.(print_string [red] "\n\n\n\n\n\n\n\n\n");
  ANSITerminal.(print_string [red] "                     __      __          ___                                          __                                     ");
  ANSITerminal.(print_string [red] "                    /\\ \\  __/\\ \\        /\\_ \\                                        /\\ \\__                                  ");
  ANSITerminal.(print_string [red] "                    \\ \\ \\/\\ \\ \\ \\     __\\//\\ \\     ___    ___     ___ ___      __    \\ \\ ,_\\   ___                           ");
  ANSITerminal.(print_string [red] "                     \\ \\ \\ \\ \\ \\ \\  /'__`\\\\ \\ \\   /'___\\ / __`\\ /' __` __`\\  /'__`\\   \\ \\ \\/  / __`\\                         ");
  ANSITerminal.(print_string [red] "                      \\ \\ \\_/ \\_\\ \\/\\  __/ \\_\\ \\_/\\ \\__//\\ \\L\\ \\/\\ \\/\\ \\/\\ \\/\\  __/    \\ \\ \\_/\\ \\L\\ \\                        ");
  ANSITerminal.(print_string [red] "                       \\ `\\___x___/\\ \\____\\/\\____\\ \\____\\ \\____/\\ \\_\\ \\_\\ \\_\\ \\____\\    \\ \\__\\ \\____/                        ");
  ANSITerminal.(print_string [red] "                        '\\/__//__/  \\/____/\\/____/\\/____/\\/___/  \\/_/\\/_/\\/_/\\/____/     \\/__/\\/___/                         ");
  print_endline("\n\n\n\n");
  ANSITerminal.(print_string [cyan] "                                     ____     ____           __       _     _     __                                         ");
  ANSITerminal.(print_string [cyan] "                                    /\\  _`\\  /\\  _`\\       /'__`\\   /' \\  /' \\  /'__`\\                                       ");
  ANSITerminal.(print_string [cyan] "                                    \\ \\ \\/\\_\\\\ \\,\\L\\_\\    /\\_\\L\\ \\ /\\_, \\/\\_, \\/\\ \\/\\ \\                                      ");
  ANSITerminal.(print_string [cyan] "                                     \\ \\ \\/_/_\\/_\\__ \\    \\/_/_\\_<_\\/_/\\ \\/_/\\ \\ \\ \\ \\ \\                                     ");
  ANSITerminal.(print_string [cyan] "                                      \\ \\ \\L\\ \\ /\\ \\L\\ \\    /\\ \\L\\ \\  \\ \\ \\ \\ \\ \\ \\ \\_\\ \\                                    ");
  ANSITerminal.(print_string [cyan] "                                       \\ \\____/ \\ `\\____\\   \\ \\____/   \\ \\_\\ \\ \\_\\ \\____/                                    ");
  ANSITerminal.(print_string [cyan] "                                        \\/___/   \\/_____/    \\/___/     \\/_/  \\/_/\\/___/                                     ");
  print_endline("\n\n\n\n");
  ANSITerminal.(print_string [green] "                                                                                  ___                                                  ");
  ANSITerminal.(print_string [green] "                        /'\\_/`\\                                        /\\_ \\                                                 ");
  ANSITerminal.(print_string [green] "                       /\\      \\    ___     ___     ___   _____     ___\\//\\ \\    __  __                                      ");
  ANSITerminal.(print_string [green] "                       \\ \\ \\__\\ \\  / __`\\ /' _ `\\  / __`\\/\\ '__`\\  / __`\\\\ \\ \\  /\\ \\/\\ \\                                     ");
  ANSITerminal.(print_string [green] "                        \\ \\ \\_/\\ \\/\\ \\L\\ \\/\\ \\/\\ \\/\\ \\L\\ \\ \\ \\L\\ \\/\\ \\L\\ \\\\_\\ \\_\\ \\ \\_\\ \\                                    ");
  ANSITerminal.(print_string [green] "                         \\ \\_\\\\ \\_\\ \\____/\\ \\_\\ \\_\\ \\____/\\ \\ ,__/\\ \\____//\\____\\\\/`____ \\                                   ");
  ANSITerminal.(print_string [green] "                          \\/_/ \\/_/\\/___/  \\/_/\\/_/\\/___/  \\ \\ \\/  \\/___/ \\/____/ `/___/> \\                                  ");
  ANSITerminal.(print_string [green] "                                                            \\ \\_\\                    /\\___/                                  ");
  ANSITerminal.(print_string [green] "                                                             \\/_/                    \\/__/                                   ");
  ANSITerminal.resize 125 55;
  print_endline("\n\n\n\n");
  print_endline "                          Please enter the number of players you want. You can play with either 2, 3 or 4.\n\n\n\n\n\n\n\n"; 
  print_string  "> ";
  get_num()


(* Execute the game engine. *)
let a = main ()




